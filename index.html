<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hamming Code Audio Encoder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple animation for the button */
        button:active {
            transform: scale(0.98);
        }
        /* Custom styles for disabled button */
        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 border border-gray-700">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-cyan-400">Telecommunication System Encoder</h1>
            <p class="text-gray-400 mt-2">Enter a binary message to encode it with Hamming parity and play the audio signal.</p>
        </div>

        <!-- Input Section -->
        <div class="mb-6">
            <label for="bitstring-input" class="block text-sm font-medium text-gray-300 mb-2">Binary Message (up to 20 bits)</label>
            <input type="text" id="bitstring-input" maxlength="20" class="w-full bg-gray-900 border border-gray-600 text-gray-200 rounded-lg p-3 text-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 transition" placeholder="e.g., 1100">
            <p id="error-message" class="text-red-400 text-sm mt-2 h-5"></p>
        </div>

        <!-- Control Button -->
        <div class="flex justify-center mb-6">
            <button id="play-button" class="w-full md:w-auto bg-cyan-500 hover:bg-cyan-600 text-gray-900 font-bold py-3 px-8 rounded-lg shadow-lg transition-all duration-200 ease-in-out text-lg">
                Encode and Play Audio
            </button>
        </div>

        <!-- Output Section -->
        <div id="output-section" class="bg-gray-900/50 p-4 rounded-lg border border-gray-700 space-y-3 hidden">
            <h2 class="text-xl font-semibold text-cyan-300 border-b border-gray-600 pb-2 mb-3">Encoding Results</h2>
            <div>
                <p class="text-sm text-gray-400">Original Message:</p>
                <p id="original-message" class="font-mono text-lg text-white break-all"></p>
            </div>
            <div>
                <p class="text-sm text-gray-400">Payload (Length + Message):</p>
                <p id="payload" class="font-mono text-lg text-white break-all"></p>
            </div>
            <div>
                <p class="text-sm text-gray-400">Calculated Parity Bits:</p>
                <p id="parity-bits" class="font-mono text-lg text-white break-all"></p>
            </div>
            <div>
                <p class="text-sm text-gray-400">Parity-check (global) bit:</p>
                <p id="parity-check-bit" class="font-mono text-lg text-yellow-300 break-all"></p>
            </div>
            <div class="pt-2">
                <p class="text-sm text-gray-400">Full Transmitted String:</p>
                <p id="transmitted-string" class="font-mono text-lg text-green-400 break-all"></p>
            </div>
        </div>
        
        <!-- Status Indicator -->
        <div id="status" class="text-center mt-4 text-yellow-400 h-6"></div>

    </div>

    <script>
        // --- DOM Elements ---
        const input = document.getElementById('bitstring-input');
        const playButton = document.getElementById('play-button');
        const errorMessage = document.getElementById('error-message');
        const status = document.getElementById('status');
        const outputSection = document.getElementById('output-section');

        // --- Audio Parameters ---
        const FREQ_1 = 1500; // Hz for logical '1'
        const FREQ_0 = 500;  // Hz for logical '0'
        const BIT_MS = 300;  // Tone duration per bit (ms)
        const GAP_MS = 300;   // Silence between bits (ms)
        const START_FREQ = 5000; // Hz for start and end of message
        const START_MS = 100; // duration for the start/end tone (ms)

        // --- Hamming Code Parameters ---
        const R = 5;
        const N = 2**R - 1; // 31
        const PARITY_POSITIONS = Array.from({ length: R }, (_, i) => 2**i); // [1, 2, 4, 8, 16]

        // This is a JavaScript port of the Python encoding logic.
        function createTransmittedString(dataBits) {
            const messageLen = dataBits.length;
            // format(message_len, '05b') -> .toString(2).padStart(5, '0')
            const lengthPrefix = messageLen.toString(2).padStart(5, '0');
            const payload = lengthPrefix + dataBits;

            // Build the conceptual 31-bit codeword for calculation
            const codewordForCalc = Array(N + 1).fill('0');
            
            let payloadIdx = 0;
            for (let pos = 1; pos <= N; pos++) {
                if (PARITY_POSITIONS.includes(pos)) continue;
                
                if (payloadIdx < payload.length) {
                    codewordForCalc[pos] = payload[payloadIdx];
                    payloadIdx++;
                }
            }
            
            // Compute the 5 parity bits
            let finalParityString = '';
            for (const pPos of PARITY_POSITIONS) {
                let xorSum = 0;
                for (let bitPos = 1; bitPos <= N; bitPos++) {
                    if ((bitPos & pPos) !== 0) {
                        xorSum ^= parseInt(codewordForCalc[bitPos]);
                    }
                }
                finalParityString += xorSum.toString();
            }
            // append one more bit which is xor of the 5 parity bits (global parity-check)
            let finalParityXor = 0;
            for (const bit of finalParityString) {
                finalParityXor ^= parseInt(bit);
            } 

            return payload + finalParityString + finalParityXor.toString();
        }

        // Web Audio API implementation for playing tones
        let audioContext;
        
        // Utility function for creating delays
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // helper to play a single tone of given frequency and duration (ms)
        async function playTone(freq, durationMs, includeGap = true) {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    status.textContent = "Error: Web Audio API is not supported in this browser.";
                    throw e;
                }
            }
            // resume context in case it's suspended (required on some browsers)
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            oscillator.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + durationMs / 1000);

            // await the duration, plus optional small gap
            if (includeGap) {
                await sleep(durationMs + GAP_MS);
            } else {
                await sleep(durationMs);
            }
        }

        async function playBits(bits) {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            } catch (e) {
                status.textContent = "Error: Web Audio API is not supported in this browser.";
                return;
            }
            
            playButton.disabled = true;
            status.textContent = 'Preparing audio...';

            // Play start tone
            status.textContent = 'Playing start tone';
            await playTone(START_FREQ, START_MS);

            // Play each bit
            for (let i = 0; i < bits.length; i++) {
                const bit = bits[i];
                status.textContent = `Playing bit ${i + 1}/${bits.length}: ${bit}`;
                const freq = bit === '1' ? FREQ_1 : FREQ_0;
                await playTone(freq, BIT_MS);
            }

            // Play end tone
            status.textContent = 'Playing end tone';
            await playTone(START_FREQ, START_MS, false);

            status.textContent = 'âœ… Playback complete!';
            playButton.disabled = false;
        }

        // Event Listener for the button
        playButton.addEventListener('click', () => {
            const dataBits = input.value;
            
            // Input validation
            if (!/^[01]+$/.test(dataBits) || dataBits.length === 0 || dataBits.length > 20) {
                errorMessage.textContent = "Invalid input. Use only 0/1, length 1-20.";
                outputSection.classList.add('hidden');
                return;
            }
            errorMessage.textContent = '';

            // Perform encoding
            const txString = createTransmittedString(dataBits);
            const payload = txString.slice(0, -R - 1); // payload is up to before parity bits (5) + parity-check (1)
            // But for display you previously used slice(0, -R) - that included the parity-check; keep both for clarity below
            const payloadAlt = txString.slice(0, -R); // payload + parity-check removed? (we keep both here)
            const parity = txString.slice(-(R+1), -1); // last R bits except the final parity-check
            const paritybit = txString.slice(-1); // final parity-check bit

            // Display results
            document.getElementById('original-message').textContent = dataBits;
            // which payload to show: the intended human payload is length-prefix + dataBits => that's txString.slice(0, payload.length)
            document.getElementById('payload').textContent = txString.slice(0, txString.length - (R + 1)); // length + message
            document.getElementById('parity-bits').textContent = parity;
            document.getElementById('parity-check-bit').textContent = paritybit;
            document.getElementById('transmitted-string').textContent = txString;
            outputSection.classList.remove('hidden');

            // Play the audio (entire transmitted string includes parity-check as last bit)
            playBits(txString);
        });

        // Real-time input validation
        input.addEventListener('input', () => {
            const value = input.value;
            const sanitized = value.replace(/[^01]/g, '');
            if (value !== sanitized) {
                input.value = sanitized;
            }
             if (sanitized.length > 0) {
                errorMessage.textContent = '';
            }
        });
    </script>
</body>
</html>
